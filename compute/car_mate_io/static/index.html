<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice Demo ‚Äì STT & TTS (Python-Backend)</title>
  <style>
    :root { font-family: system-ui, sans-serif; }
    body { margin: 2rem; }
    .row { display: flex; gap: 1rem; flex-wrap: wrap; }
    button { padding: .7rem 1rem; border-radius: .6rem; border: 1px solid #ccc; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    textarea { width: 100%; min-height: 120px; padding: .6rem; border-radius: .6rem; border: 1px solid #ccc; }
    .card { border: 1px solid #e5e7eb; border-radius: .8rem; padding: 1rem; margin-bottom: 1rem; box-shadow: 0 1px 3px rgba(0,0,0,.05); }
    .small { color: #6b7280; font-size: .9rem; }
    .status { margin: .5rem 0; font-size: .95rem; color: #374151; }
    audio { width: 100%; margin-top: .5rem; }
  </style>
</head>
<body>
  <h1>üéôÔ∏è Speech-to-Text & üîä Text-to-Speech</h1>

  <div class="card">
    <h2>Speech-to-Text (STT)</h2>
    <p class="small">Press ‚ÄûRecord‚Äú, talk, then ‚ÄûStop &amp; Transcribe. The recording will be sent as WAV (mono, 16 kHz) to <code>/stt</code>.</p>

    <div class="row">
      <button id="btnStart">üéôÔ∏è Start Recording</button>
      <button id="btnStop" disabled>‚èπÔ∏è Stop &amp; Transcribing</button>
    </div>
    <div id="sttStatus" class="status"></div>
    <audio id="sttPlayback" controls></audio>
    <label class="small"><input type="checkbox" id="playbackToggle" checked /> Play own Recording</label>

    <h3>Result</h3>
    <textarea id="sttResult" placeholder="The transcript will be shown here‚Ä¶" readonly></textarea>
  </div>

  <div class="card">
    <h2>Text-to-Speech (TTS)</h2>
    <p class="small">Type in your text - it will be synthesized.</p>
    <textarea id="ttsInput" placeholder="Type in your text - it will be synthesized ‚Ä¶">Hello from Python TTS!</textarea>
    <div class="row">
      <button id="btnSpeak">üîä Speak</button>
    </div>
    <div id="ttsStatus" class="status"></div>
    <audio id="ttsAudio" controls></audio>
  </div>

<script>
(() => {
  // ======== WAV-Encoder (PCM 16-bit, mono, 16kHz) ========
  function encodeWAV(samples, sampleRate) {
    // Downsample to 16kHz, mono
    const targetRate = 16000;
    const ratio = sampleRate / targetRate;
    const newLength = Math.round(samples.length / ratio);
    const downsampled = new Float32Array(newLength);
    let offsetResult = 0;
    let offsetBuffer = 0;
    while (offsetResult < newLength) {
      const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
      let accum = 0, count = 0;
      for (let i = offsetBuffer; i < nextOffsetBuffer && i < samples.length; i++) {
        accum += samples[i];
        count++;
      }
      downsampled[offsetResult] = accum / (count || 1);
      offsetResult++;
      offsetBuffer = nextOffsetBuffer;
    }

    // Float32 -> PCM16
    const buffer = new ArrayBuffer(44 + downsampled.length * 2);
    const view = new DataView(buffer);

    function writeString(view, offset, string) {
      for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
      }
    }

    let offset = 0;
    // RIFF header
    writeString(view, 0, 'RIFF'); offset += 4;
    view.setUint32(4, 36 + downsampled.length * 2, true);
    writeString(view, 8, 'WAVE'); offset += 8;

    // fmt chunk
    writeString(view, 12, 'fmt '); // 4
    view.setUint32(16, 16, true);  // Subchunk1Size (16 for PCM)
    view.setUint16(20, 1, true);   // AudioFormat (1 = PCM)
    view.setUint16(22, 1, true);   // NumChannels (mono)
    view.setUint32(24, 16000, true); // SampleRate
    view.setUint32(28, 16000 * 2, true); // ByteRate (SampleRate * NumChannels * BytesPerSample)
    view.setUint16(32, 2, true);   // BlockAlign (NumChannels * BytesPerSample)
    view.setUint16(34, 16, true);  // BitsPerSample
    // data chunk
    writeString(view, 36, 'data');
    view.setUint32(40, downsampled.length * 2, true);

    // PCM samples
    let idx = 44;
    for (let i = 0; i < downsampled.length; i++, idx += 2) {
      let s = Math.max(-1, Math.min(1, downsampled[i]));
      view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }

    return new Blob([view], { type: 'audio/wav' });
  }

  // ======== Recording & STT ========
  let mediaStream = null;
  let audioCtx = null;
  let processor = null;
  let sourceNode = null;
  let recorded = [];

  const btnStart = document.getElementById('btnStart');
  const btnStop = document.getElementById('btnStop');
  const sttStatus = document.getElementById('sttStatus');
  const sttPlayback = document.getElementById('sttPlayback');
  const playbackToggle = document.getElementById('playbackToggle');
  const sttResult = document.getElementById('sttResult');

  btnStart.onclick = async () => {
    recorded = [];
    sttResult.value = '';
    sttStatus.textContent = 'Initialisiere Mikrofon‚Ä¶';
    btnStart.disabled = true;

    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sourceNode = audioCtx.createMediaStreamSource(mediaStream);
      processor = audioCtx.createScriptProcessor(4096, 1, 1);

      sourceNode.connect(processor);
      processor.connect(audioCtx.destination);

      processor.onaudioprocess = e => {
        const channel = e.inputBuffer.getChannelData(0);
        // Copy, to not overflow the ringbuffer
        recorded.push(new Float32Array(channel));
      };

      sttStatus.textContent = 'üéôÔ∏è Recording‚Ä¶';
      btnStop.disabled = false;
    } catch (err) {
      console.error(err);
      sttStatus.textContent = 'Microphone access denied or not available.';
      btnStart.disabled = false;
    }
  };

  btnStop.onclick = async () => {
    btnStop.disabled = true;
    sttStatus.textContent = 'Stop & process‚Ä¶';

    // Stop audio
    if (processor) processor.disconnect();
    if (sourceNode) sourceNode.disconnect();
    if (audioCtx) await audioCtx.close();
    if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());

    // Samples merging
    let length = recorded.reduce((acc, cur) => acc + cur.length, 0);
    const merged = new Float32Array(length);
    let offset = 0;
    for (const chunk of recorded) {
      merged.set(chunk, offset);
      offset += chunk.length;
    }

    // WAV-Blob creation (mono, 16 kHz, PCM16)
    const wavBlob = encodeWAV(merged, (window.AudioContext || window.webkitAudioContext) ? (audioCtx?.sampleRate || 48000) : 48000);
    if (playbackToggle.checked) {
      sttPlayback.src = URL.createObjectURL(wavBlob);
      sttPlayback.play().catch(()=>{});
    }

    sttStatus.textContent = 'Send to server‚Ä¶';
    const form = new FormData();
    form.append('audio', wavBlob, 'recording.wav');

    try {
      const res = await fetch('/stt', { method: 'POST', body: form });
      const data = await res.json();
      if (data.error) {
        sttStatus.textContent = 'Error: ' + data.error;
      } else {
        sttStatus.textContent = 'Done ‚úÖ';
        sttResult.value = data.text || (data.message ? `[${data.message}]` : '');
        console.log("data.text:" + data.text)
        console.log("data.message:" + data.message)
      }
    } catch (e) {
      console.error(e);
      sttStatus.textContent = 'Network error while sending.';
    }

    btnStart.disabled = false;
  };

  // ======== TTS ========
  const btnSpeak = document.getElementById('btnSpeak');
  const ttsInput = document.getElementById('ttsInput');
  const ttsStatus = document.getElementById('ttsStatus');
  const ttsAudio = document.getElementById('ttsAudio');

  btnSpeak.onclick = async () => {
    const text = ttsInput.value.trim();
    if (!text) {
      ttsStatus.textContent = 'Please inout text.';
      return;
    }
    ttsStatus.textContent = 'Create Audio‚Ä¶';
    btnSpeak.disabled = true;

    try {
      const res = await fetch('/tts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text })
      });
      if (!res.ok) {
        const err = await res.json().catch(()=>({error: 'Unknown error'}));
        ttsStatus.textContent = 'Fehler: ' + (err.error || res.statusText);
      } else {
        const blob = await res.blob();
        ttsAudio.src = URL.createObjectURL(blob);
        await ttsAudio.play().catch(()=>{});
        ttsStatus.textContent = 'Done ‚úÖ';
      }
    } catch (e) {
      console.error(e);
      ttsStatus.textContent = 'Network error.';
    } finally {
      btnSpeak.disabled = false;
    }
  };
})();
</script>
</body>
</html>
