<!--
Copyright (c) 2025 Eclipse Foundation and others.

See the NOTICE file(s) distributed with this work for additional
information regarding copyright ownership.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

SPDX-License-Identifier: Apache-2.0
-->
<!doctype html>
<html lang="de">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CarByte CarMate</title>
  <style>
    :root {
      font-family: system-ui, sans-serif;
    }

    body {
      margin: 2rem;
    }

    .card-container {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap; /* wrap on smaller screens */
    }

    .card {
      flex: 1 1 40%;
      min-width: 300px;
      border: 1px solid #e5e7eb;
      border-radius: .8rem;
      padding: 1rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, .05);
      box-sizing: border-box;
    }

    /* The image column - 15% width fixed basis */
    .image-column {
      flex: 0 0 15%;
      display: flex;
      justify-content: center;
      align-items: center;
      min-width: 100px;
      margin-bottom: 1rem;
    }

    .image-column img {
      width: auto;
      height: 50px;
      max-width: 100%;
      display: block;
    }

    .small {
      color: #6b7280;
      font-size: .9rem;
    }

    .status {
      margin: .5rem 0;
      font-size: .95rem;
      color: #374151;
    }

    button {
      padding: .7rem 1rem;
      border-radius: .6rem;
      border: 1px solid #ccc;
      cursor: pointer;
    }

    button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    textarea {
      width: 95%;
      min-height: 120px;
      padding: .6rem;
      border-radius: .6rem;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }

    audio {
      width: 100%;
      margin-top: .5rem;
    }
  </style>
</head>

<body>
  <h1 style="display: flex; align-items: center; gap: 0.5rem; justify-content: center; text-align: center;">
    <img src="static/logo.png" style="width: auto; height: 50px;" alt="Logo" />
    CarByte CarMate
  </h1>
  <div class="card-container">
    <div class="card">
      <h2>üéôÔ∏è Ask CarMate (STT)</h2>
      <p class="small"> Press talk to talk to your personal CarMate to <code>/stt</code>.</p>

      <div class="row">
        <button id="btnStart">üéôÔ∏è talk</button>
        <button id="btnStop" disabled>‚èπÔ∏è stop </button>
      </div>
      <div id="sttStatus" class="status"></div>
      <audio id="sttPlayback" controls></audio>
      <label class="small"><input type="checkbox" id="playbackToggle" /> Play own Recording</label>

      <h3>Your Input</h3>
      <textarea id="sttResult" placeholder="Your audio will be shown here" readonly></textarea>
    </div>

    <div class="image-column">
      <img src="static/mate.png" alt="Mate" style="width: auto; height: auto;">
    </div>

    <div class="card">
      <h2>üîä CarMate Response (TTS)</h2>
      <textarea id="ttsInput" placeholder="Waiting for answer from CarMate"></textarea>
      <div id="ttsStatus" class="status"></div>
      <audio id="ttsAudio" controls></audio>
    </div>
  </div>
  <script>
    (() => {
      // ======== WAV-Encoder (PCM 16-bit, mono, 16kHz) ========
      function encodeWAV(samples, sampleRate) {
        // Downsample to 16kHz, mono
        const targetRate = 16000;
        const ratio = sampleRate / targetRate;
        const newLength = Math.round(samples.length / ratio);
        const downsampled = new Float32Array(newLength);
        let offsetResult = 0;
        let offsetBuffer = 0;
        while (offsetResult < newLength) {
          const nextOffsetBuffer = Math.round((offsetResult + 1) * ratio);
          let accum = 0, count = 0;
          for (let i = offsetBuffer; i < nextOffsetBuffer && i < samples.length; i++) {
            accum += samples[i];
            count++;
          }
          downsampled[offsetResult] = accum / (count || 1);
          offsetResult++;
          offsetBuffer = nextOffsetBuffer;
        }

        // Float32 -> PCM16
        const buffer = new ArrayBuffer(44 + downsampled.length * 2);
        const view = new DataView(buffer);

        function writeString(view, offset, string) {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        }

        let offset = 0;
        // RIFF header
        writeString(view, 0, 'RIFF'); offset += 4;
        view.setUint32(4, 36 + downsampled.length * 2, true);
        writeString(view, 8, 'WAVE'); offset += 8;

        // fmt chunk
        writeString(view, 12, 'fmt '); // 4
        view.setUint32(16, 16, true);  // Subchunk1Size (16 for PCM)
        view.setUint16(20, 1, true);   // AudioFormat (1 = PCM)
        view.setUint16(22, 1, true);   // NumChannels (mono)
        view.setUint32(24, 16000, true); // SampleRate
        view.setUint32(28, 16000 * 2, true); // ByteRate (SampleRate * NumChannels * BytesPerSample)
        view.setUint16(32, 2, true);   // BlockAlign (NumChannels * BytesPerSample)
        view.setUint16(34, 16, true);  // BitsPerSample
        // data chunk
        writeString(view, 36, 'data');
        view.setUint32(40, downsampled.length * 2, true);

        // PCM samples
        let idx = 44;
        for (let i = 0; i < downsampled.length; i++, idx += 2) {
          let s = Math.max(-1, Math.min(1, downsampled[i]));
          view.setInt16(idx, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }

        return new Blob([view], { type: 'audio/wav' });
      }

      // ======== Recording & STT ========
      let mediaStream = null;
      let audioCtx = null;
      let processor = null;
      let sourceNode = null;
      let recorded = [];

      const btnStart = document.getElementById('btnStart');
      const btnStop = document.getElementById('btnStop');
      const sttStatus = document.getElementById('sttStatus');
      const sttPlayback = document.getElementById('sttPlayback');
      const playbackToggle = document.getElementById('playbackToggle');
      const sttResult = document.getElementById('sttResult');

      btnStart.onclick = async () => {
        recorded = [];
        sttResult.value = '';
        sttStatus.textContent = 'Initialize Microphone';
        btnStart.disabled = true;

        try {
          mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          sourceNode = audioCtx.createMediaStreamSource(mediaStream);
          processor = audioCtx.createScriptProcessor(4096, 1, 1);

          sourceNode.connect(processor);
          processor.connect(audioCtx.destination);

          processor.onaudioprocess = e => {
            const channel = e.inputBuffer.getChannelData(0);
            // Copy, to not overflow the ringbuffer
            recorded.push(new Float32Array(channel));
          };

          sttStatus.textContent = 'üéôÔ∏è Recording‚Ä¶';
          btnStop.disabled = false;
        } catch (err) {
          console.error(err);
          sttStatus.textContent = 'Microphone access denied or not available.';
          btnStart.disabled = false;
        }
      };

      btnStop.onclick = async () => {
        btnStop.disabled = true;
        sttStatus.textContent = 'Stop & process‚Ä¶';

        // Stop audio
        if (processor) processor.disconnect();
        if (sourceNode) sourceNode.disconnect();
        if (audioCtx) await audioCtx.close();
        if (mediaStream) mediaStream.getTracks().forEach(t => t.stop());

        // Samples merging
        let length = recorded.reduce((acc, cur) => acc + cur.length, 0);
        const merged = new Float32Array(length);
        let offset = 0;
        for (const chunk of recorded) {
          merged.set(chunk, offset);
          offset += chunk.length;
        }

        // WAV-Blob creation (mono, 16 kHz, PCM16)
        const wavBlob = encodeWAV(merged, (window.AudioContext || window.webkitAudioContext) ? (audioCtx?.sampleRate || 48000) : 48000);
        if (playbackToggle.checked) {
          sttPlayback.src = URL.createObjectURL(wavBlob);
          sttPlayback.play().catch(() => { });
        }

        sttStatus.textContent = 'Send to server‚Ä¶';
        const form = new FormData();
        form.append('audio', wavBlob, 'recording.wav');

        try {
          const res = await fetch('/stt', { method: 'POST', body: form });
          const data = await res.json();
          if (data.error) {
            sttStatus.textContent = 'Error: ' + data.error;
          } else {
            sttStatus.textContent = 'Done ‚úÖ';
            sttResult.value = data.text;

            text = data.text
            console.log("sst text:" + text)

            const res_rpc = await fetch('/rpc', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text }) });
            const rpc_data = await res_rpc.json();
            console.log(rpc_data)
            text = rpc_data.text

            ttsInput.value = text;

            ttsStatus.textContent = 'Create Audio‚Ä¶';

            try {
            console.log("tts_text: " + text)

              const res_tts = await fetch('/tts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text })
              });
              if (!res_tts.ok) {
                const err = await res_tts.json().catch(() => ({ error: 'Unknown error' }));
                ttsStatus.textContent = 'Fehler: ' + (err.error || res_tts.statusText);
              } else {
                const blob = await res_tts.blob();
                ttsAudio.src = URL.createObjectURL(blob);
                await ttsAudio.play().catch(() => { });
                ttsStatus.textContent = 'Done ‚úÖ';
              }
            } catch (e) {
              console.error(e);
              ttsStatus.textContent = 'Network error.';
            } finally {
              btnSpeak.disabled = false;
            }
          }
        } catch (e) {
          console.error(e);
          sttStatus.textContent = 'Network error while sending.';
        }

        btnStart.disabled = false;
      };

      // ======== TTS ========
      const btnSpeak = document.getElementById('btnSpeak');
      const ttsInput = document.getElementById('ttsInput');
      const ttsStatus = document.getElementById('ttsStatus');
      const ttsAudio = document.getElementById('ttsAudio');

      btnSpeak.onclick = async () => {
        const text = ttsInput.value.trim();
        if (!text) {
          ttsStatus.textContent = 'Please inout text.';
          return;
        }
        ttsStatus.textContent = 'Create Audio‚Ä¶';
        btnSpeak.disabled = true;

        try {
          const res = await fetch('/tts', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ text })
          });
          if (!res.ok) {
            const err = await res.json().catch(() => ({ error: 'Unknown error' }));
            ttsStatus.textContent = 'Fehler: ' + (err.error || res.statusText);
          } else {
            const blob = await res.blob();
            ttsAudio.src = URL.createObjectURL(blob);
            await ttsAudio.play().catch(() => { });
          }
        } catch (e) {
          console.error(e);
          ttsStatus.textContent = 'Network error.';
        } finally {
          btnSpeak.disabled = false;
        }
      };
    })();
  </script>
</body>

</html>